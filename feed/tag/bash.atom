<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>RyanCollins.org - bash</title><link href="//ryancollins.org/" rel="alternate"></link><link href="//ryancollins.org/feed/tag/bash.atom" rel="self"></link><id>//ryancollins.org/</id><updated>2016-02-03T09:02:00-05:00</updated><entry><title>Searching bash history when it's in multiple files</title><link href="//ryancollins.org/2016/02/03/searching-bash-history-when-it-s-in-multiple-files/" rel="alternate"></link><published>2016-02-03T09:02:00-05:00</published><updated>2016-02-03T09:02:00-05:00</updated><author><name>mr.rcollins</name></author><id>tag:ryancollins.org,2016-02-03:/2016/02/03/searching-bash-history-when-it-s-in-multiple-files/</id><summary type="html">&lt;p&gt;When I look for previous commands that I have ran in bash, I use &lt;code&gt;history | grep COMMAND&lt;/code&gt;. That works well when you're history is in one file, but I now save my &lt;a href="http://ryancollins.org/2016/01/21/saving-bash-shell-history-for-multiple-shells/"&gt;history in multiple files from each shell&lt;/a&gt; and my simple command doesn't work. &lt;/p&gt;
&lt;p&gt;With my history files saved …&lt;/p&gt;</summary><content type="html">&lt;p&gt;When I look for previous commands that I have ran in bash, I use &lt;code&gt;history | grep COMMAND&lt;/code&gt;. That works well when you're history is in one file, but I now save my &lt;a href="http://ryancollins.org/2016/01/21/saving-bash-shell-history-for-multiple-shells/"&gt;history in multiple files from each shell&lt;/a&gt; and my simple command doesn't work. &lt;/p&gt;
&lt;p&gt;With my history files saved in ~/.bash_history_log/ I needed a different solution. The one I came up with is &lt;code&gt;grep -ri COMMAND ~/.bash_history_log/*&lt;/code&gt;.  That seems awfully long, lets make it shorter. You can't pass arguments to bash aliases, but you can to functions. In .bash_profile (or .bashrc, which ever runs for you by default) I added the following function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;function searchhistory() {
    grep -ri &amp;quot;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&amp;quot; ~/.bash_history_log/*
}
alias shistory=searchhistory
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And now a simple &lt;code&gt;shistory COMMAND&lt;/code&gt; is all it takes to find that command I ran a long time ago.&lt;/p&gt;</content><category term="bash"></category><category term="history"></category></entry><entry><title>A bash script to check domain expirations</title><link href="//ryancollins.org/2016/01/28/a-bash-script-to-check-domain-expirations/" rel="alternate"></link><published>2016-01-28T20:29:00-05:00</published><updated>2016-01-28T20:29:00-05:00</updated><author><name>mri_rcollins</name></author><id>tag:ryancollins.org,2016-01-28:/2016/01/28/a-bash-script-to-check-domain-expirations/</id><summary type="html">&lt;p&gt;I have a bad habit, and that's of buying domain names. I have about 20, with several different registrars. If I was smart, I would consolidate them under one registrar, but, even then, checking expirations on the domains is a pain. I usually have autorenew turned on, but I still …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I have a bad habit, and that's of buying domain names. I have about 20, with several different registrars. If I was smart, I would consolidate them under one registrar, but, even then, checking expirations on the domains is a pain. I usually have autorenew turned on, but I still like to know when they are getting close to expiration. &lt;/p&gt;
&lt;p&gt;Before re-inventing the wheel, I did a Google search, and found &lt;a href="http://www.cyberciti.biz/tips/domain-check-script.html"&gt;Domain Expiration Check Shell Script&lt;/a&gt;. It worked pretty well, except for a few top level domains like .me which didn't work. I modified the script, and just had to put some finishing touches on it today (.com, .net,  and .org was broken). Check &lt;a href="https://gist.github.com/mrrcollins/9a668109fa8a97f9fb90"&gt;out the gist of the script on Github&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;I put all of my domains in a text file, and can then run it with &lt;code&gt;./domain-check -f mydomains.txt&lt;/code&gt;. It's pretty cool.&lt;/p&gt;</content><category term="domains"></category><category term="bash"></category></entry><entry><title>Fixing my .taskpaper reset alias for bash</title><link href="//ryancollins.org/2016/01/26/fixing-my-taskpaper-reset-alias-for-bash/" rel="alternate"></link><published>2016-01-26T09:01:00-05:00</published><updated>2016-01-26T09:01:00-05:00</updated><author><name>mr.rcollins</name></author><id>tag:ryancollins.org,2016-01-26:/2016/01/26/fixing-my-taskpaper-reset-alias-for-bash/</id><summary type="html">&lt;p&gt;There was a little problem with my alias to reset a .taskpaper list by removing all of the @dones. It didn't remove any spaces before the @done, so each line would gain a space every day. This fixes it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;alias rst=&amp;quot;sed -i &amp;#39;&amp;#39; &amp;#39;s/ *@done\(.*\)//g&amp;#39;&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now it removes one …&lt;/p&gt;</summary><content type="html">&lt;p&gt;There was a little problem with my alias to reset a .taskpaper list by removing all of the @dones. It didn't remove any spaces before the @done, so each line would gain a space every day. This fixes it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;alias rst=&amp;quot;sed -i &amp;#39;&amp;#39; &amp;#39;s/ *@done\(.*\)//g&amp;#39;&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now it removes one or more spaces that could be before @done.&lt;/p&gt;</content><category term="bash"></category><category term="taskpaper"></category></entry><entry><title>Using a Here Document with bash and MySQL</title><link href="//ryancollins.org/2016/01/23/using-a-here-document-with-bash-and-mysql/" rel="alternate"></link><published>2016-01-23T19:58:00-05:00</published><updated>2016-01-23T19:58:00-05:00</updated><author><name>mrrcollins</name></author><id>tag:ryancollins.org,2016-01-23:/2016/01/23/using-a-here-document-with-bash-and-mysql/</id><summary type="html">&lt;p&gt;This past week I worked on a bash script to create some input files from a MySQL database. My problem was trying to use multiple line MySQL statements, which was messing everything up. The solution was to use bash's &lt;strong&gt;Here Documents&lt;/strong&gt;. It's a way to direct lines into a command …&lt;/p&gt;</summary><content type="html">&lt;p&gt;This past week I worked on a bash script to create some input files from a MySQL database. My problem was trying to use multiple line MySQL statements, which was messing everything up. The solution was to use bash's &lt;strong&gt;Here Documents&lt;/strong&gt;. It's a way to direct lines into a command. For me, the command looked like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;mysql DBNAME &amp;lt;&amp;lt;EOF
SELECT *
FROM table
WHERE item = &amp;#39;WhatIWant&amp;#39;
EOF
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Everything between the two EOF would be submitted to MySQL. The next problem was that bash was trying to still interpret the MySQL statement which had backticks in it. To solve this issue, I learned that I needed to enclose the first EOF in quotes.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;mysql DBNAME &amp;lt;&amp;lt;&amp;quot;EOF&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Bash then left my MySQL command alone, and all was right in the world.&lt;/p&gt;</content><category term="bash"></category><category term="mysql"></category></entry><entry><title>Resetting a daily taskpaper list</title><link href="//ryancollins.org/2016/01/22/resetting-a-daily-taskpaper-list/" rel="alternate"></link><published>2016-01-22T10:05:00-05:00</published><updated>2016-01-22T10:05:00-05:00</updated><author><name>mr.rcollins</name></author><id>tag:ryancollins.org,2016-01-22:/2016/01/22/resetting-a-daily-taskpaper-list/</id><summary type="html">&lt;p&gt;I have a couple &lt;a href="http://eduk8.me/2016/01/managing-checklists-in-google-keep-or-using-taskpaper-with-drafts-for-ios/"&gt;daily taskpaper lists&lt;/a&gt; that by the end of the have an @done on each line and I need to reset it for the next day. Instead of trying to do a search and replace everyday, I added a bash alias to .bash_profile (or .bashrc):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;alias rst …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;I have a couple &lt;a href="http://eduk8.me/2016/01/managing-checklists-in-google-keep-or-using-taskpaper-with-drafts-for-ios/"&gt;daily taskpaper lists&lt;/a&gt; that by the end of the have an @done on each line and I need to reset it for the next day. Instead of trying to do a search and replace everyday, I added a bash alias to .bash_profile (or .bashrc):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;alias rst=&amp;quot;sed -i &amp;#39;&amp;#39; &amp;#39;s/@done\(.*\)//g&amp;#39;&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The extra &lt;code&gt;''&lt;/code&gt; after the -i is because OS X's sed requires an extension for backups. Set it to nothing and OS X won't create backups.&lt;/p&gt;</content><category term="taskpaper"></category><category term="bash"></category></entry><entry><title>Saving bash shell history for multiple shells</title><link href="//ryancollins.org/2016/01/21/saving-bash-shell-history-for-multiple-shells/" rel="alternate"></link><published>2016-01-21T09:11:00-05:00</published><updated>2016-01-21T09:11:00-05:00</updated><author><name>mr.rcollins</name></author><id>tag:ryancollins.org,2016-01-21:/2016/01/21/saving-bash-shell-history-for-multiple-shells/</id><summary type="html">&lt;p&gt;The history from the commands typed into bash are very useful from time to time, especially when I think "Oh, I'll remember that command next time I need it", and then I don't. The problem with bash's history are twofold:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It only saves history when the terminal exits cleanly, so …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;The history from the commands typed into bash are very useful from time to time, especially when I think "Oh, I'll remember that command next time I need it", and then I don't. The problem with bash's history are twofold:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It only saves history when the terminal exits cleanly, so if your connection drops or you have to kill the current process, you lose your history.&lt;/li&gt;
&lt;li&gt;If you are running multiple terminals, or using a terminal multiplexer like tmux (my favorite!) or screen, the last bash to exit overwrites any other history with its history.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, after &lt;a href="http://unix.stackexchange.com/questions/1288/preserve-bash-history-in-multiple-terminal-windows"&gt;a little searching&lt;/a&gt; I've found a solution that works for me for now.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="x"&gt; Save history&lt;/span&gt;
&lt;span class="cp"&gt;#&lt;/span&gt;&lt;span class="nf"&gt;Set&lt;/span&gt;&lt;span class="x"&gt; history suffix to the current terminal&lt;/span&gt;
&lt;span class="x"&gt;HISTSUFFIX=`tty | sed &amp;#39;s/\///g;s/^dev//g&amp;#39;`&lt;/span&gt;
&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="x"&gt; All terminals&amp;#39; histories will be stored in separate files&lt;/span&gt;
&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="x"&gt; in .bash_history_log. That folder will need to be created.&lt;/span&gt;
&lt;span class="x"&gt;HISTFILE=&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;HOME&lt;/span&gt;&lt;span class="x"&gt;/.bash_history_log/bash_history_&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;HISTSUFFIX&lt;/span&gt;&lt;span class="x"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="x"&gt; Time stamp the commands in the history file&lt;/span&gt;
&lt;span class="x"&gt;HISTTIMEFORMAT=&amp;quot;%y-%m-%d %H:%M:%S &amp;quot;&lt;/span&gt;
&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="x"&gt; Don&amp;#39;t save duplicate commands&lt;/span&gt;
&lt;span class="x"&gt;HISTCONTROL=ignoredups:ignorespace&lt;/span&gt;
&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="x"&gt; Control the size of the file&lt;/span&gt;
&lt;span class="x"&gt;HISTSIZE=1000&lt;/span&gt;
&lt;span class="x"&gt;HISTFILESIZE=5000&lt;/span&gt;
&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="x"&gt; Bash will append to the history file&lt;/span&gt;
&lt;span class="x"&gt;shopt -s histappend&lt;/span&gt;
&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="x"&gt; Bash will append to the history file after each time&lt;/span&gt;
&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="x"&gt; the prompt is shown. This way it&amp;#39;s always saved.&lt;/span&gt;
&lt;span class="x"&gt;PROMPT_COMMAND=&amp;#39;history -a&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Put that in your .bashrc and you're good to go. Comments are welcome!&lt;/p&gt;</content><category term="bash"></category></entry><entry><title>Resetting a .taskpaper file</title><link href="//ryancollins.org/2016/01/18/resetting-a-taskpaper-file/" rel="alternate"></link><published>2016-01-18T20:44:00-05:00</published><updated>2016-01-18T20:44:00-05:00</updated><author><name>mr.rcollins</name></author><id>tag:ryancollins.org,2016-01-18:/2016/01/18/resetting-a-taskpaper-file/</id><summary type="html">&lt;p&gt;I use a couple of .taskpaper files for checklists of things that need to be done every day. In it, after a task is completed the task gets an @done tag added. But the next day I want to start fresh. I could do a find/replace, but sed at …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I use a couple of .taskpaper files for checklists of things that need to be done every day. In it, after a task is completed the task gets an @done tag added. But the next day I want to start fresh. I could do a find/replace, but sed at the command line works better:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;alias rst=&amp;quot;sed -i &amp;#39;s/@done\(.*\)//&amp;#39;&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Adding the above alias to my ~/.bash_profile adds the ability to reset a taskpaper file with a simple &lt;code&gt;rst FILE.taskpaper&lt;/code&gt;. Under OS X, the -i parameter requires an extension for a backup file. You can simply have '' to set it to nothing and then a back up file won't be created.&lt;/p&gt;</content><category term="taskpaper"></category><category term="bash"></category></entry></feed>